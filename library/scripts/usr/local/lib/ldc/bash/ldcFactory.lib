#!/bin/bash
# ******************************************************************************
# ******************************************************************************
#
#   	ldcFactory.lib
#
# *****************************************************************************
#
# @author Jay Wheeler.
# @version 0.0.1
# @copyright © 2021. EarthWalk Software.
# @license Licensed under the GNU General Public License, GPL-3.0-or-later.
# @package ewsdocker/ldcLibrary
# @subpackage ldcFactory
#
# *****************************************************************************
#
#	Copyright © 2021. EarthWalk Software
#	Licensed under the GNU General Public License, GPL-3.0-or-later.
#
#   This file is part of ewsdocker/ldcLibrary.
#
#   ewsdocker/ldcLibrary is free software: you can redistribute 
#   it and/or modify it under the terms of the GNU General Public License 
#   as published by the Free Software Foundation, either version 3 of the 
#   License, or (at your option) any later version.
#
#   ewsdocker/ldcLibrary is distributed in the hope that it will 
#   be useful, but WITHOUT ANY WARRANTY; without even the implied warranty 
#   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ewsdocker/ldcLibrary.  If not, see 
#   <http://www.gnu.org/licenses/>.
#
# *****************************************************************************
#
#	Version 0.0.1 - 02-06-2021.
#
# ******************************************************************************
#
#	Dependencies:
#
#		ldcDeclare.lib
#		ldcUId.lib
#		ldcUtilities.lib
#
# ******************************************************************************
#
#	Functions:
#
#		ldcFactoryInit
#
#			Initialize factory array(s)
#
#		ldcFactoryAdd factoryName bridgeName description uidLength
#
#			Add/Create factory name and create/update factory bridge array. 
#
#		ldcFactoryExists factoryName
#
#			If the Factory Name is valid return 0, otherwise return 1
#
#		ldcFactoryBridgeExists bridgeName
#
#			Check for the requested bridge name available.
#
# ******************************************************************************
# ******************************************************************************

declare -r ldclib_ldcFactory="0.1.0"	# version of library

# ******************************************************************************
#
#	Required global declarations
#
# ******************************************************************************

declare -i ldcfac_initalized=0

declare -i ldcfac_cvalid=0			# Current entries are valid if not 0

declare    ldcfac_cuid=""			# Current factory uid
declare    ldcfac_cfactory=""		# Current factory name

declare -i ldcfac_cbrValid=0		# Current bridge keys valid if not 0
declare    ldcfac_cbrName=""		#
declare    ldcfac_cbrDescription="" #

declare -a ldcfac_cbrKeys=()		# Current bridge keys list

#declare -A ldcfac_registry=()		# Factory registry associative array

# ***************************************************************************************************
# ***************************************************************************************************
#
#          ldcfac_registry                  ldcfac_<uid1>
#          key    : attribute            key         : attribute
#		***********************        *******************************
#		*  Help   : <uid1>    *======> * JQ          : <description> *
#		***********************        *******************************
#		*  Errors : <uid2>    *        * XML         : <description> *
#		***********************        *******************************
#
# ***************************************************************************************************
# ***************************************************************************************************

# ******************************************************************************
# ******************************************************************************
#
#						Functions
#
# ******************************************************************************
# ******************************************************************************

function ldcFactoryResetGlobals()
{
	ldcfac_cvalid=0
	ldcfac_cfactory=""
	ldcfac_cuid=""

	ldcfac_cbrValid=0
	ldcfac_cbrName=""
	ldcfac_cbrDescription=""

	unset ldcfac_cbrKeys
}

# ****************************************************************************
#
#	ldcFactoryInit
#		Initialize factory array(s)
#
#	parameters:
#		none
#
#	returns:
#		0 = no errors
#		non-zero = error number
#
# ****************************************************************************
function ldcFactoryInit()
{
	local li_error=0

	while [ true ]
	do
	    [[ ${ldcfac_initalized} -eq 0 ]] || break

		(( li_error++ ))

		ldcFactoryResetGlobals

		ldcDeclareAssoc "ldcfac_registry"
		[[ $? -eq 0 ]] || break
		
		(( li_error++ ))

		li_error=0
		ldcfac_initialized=1

		break
	done

	return ${li_error}
}

# ***********************************************************************************************************
#
#	ldcFactoryExists
#		If the Factory Name is valid return 0, otherwise return 1
#
#	Parameters:
#		facname = factory name
#
#	Returns:
#       0 = valid key
#		1 = not a valid key
#
# ********************************************************************************************************
function ldcFactoryExits()
{
	ll_facname=${1:-""}
	ll_facerr=1
	
	while [ true ]
	do
		[[ -z "$ll_facname" ]] && break

		(( ll_facerr++ ))

		[[ ${ldcfac_cvalid} -eq 1 && "${ldcfac_cfname}" == "${ll_facname}" ]] ||
		 {
			ldcFactoryResetGlobals

			[[ "${!ldcfac_registry[@]}" =~ "${ll_facname}" ]] || break
		 }

		ll_facerr=0
		break
	done

	return ${ll_facerr}
}

# ***********************************************************************************************************
#
#	ldcFactoryLookup
#		Returns 0 if found, and sets global values
#
#	Parameters:
#		facname = factory name
#
#	Returns:
#       0 = valid key
#		non-zero = error code
#
# ********************************************************************************************************
function ldcFactoryLookup()
{
	local    l_facname=${1:-""}
	local -i l_facerr=1
	
	while [ true ]
	do
		ldcFactoryExists "${l_facname}"
		[[ $? -eq 0 ]] || break

		(( l_facerr++ ))

		ldcfac_cfname=${l_facname}
		ldcfac_cuid=${ldcfac_registry[$ldcfac_cfname]}

		ldcUtilVarExists ${ldcfac_cuid}
		[[ $? -eq 0 ]] || break

		ldcfac_cvalid=1
		l_facerr=0

		break
	done

	return ${l_facerr}
}

# ***********************************************************************************************************
#
#	ldcFactoryBridgeExists
#		Check for the requested factory:bridge name valid.
#			Returns 0 if the bridge name is valid, 1 if not
#
#	Parameters:
#		bridge = bridge name to check for
#		factory = (optional) factory name (default = ldcfac_cfname)
#
#	Returns:
#		0 = valid
#		1 = not valid
#
# ********************************************************************************************************
function ldcFactoryBridgeExists()
{
	local    lb_bridge=${1}
	local    lb_factory=${2:-"$ldcfac_cfname"}

	local -i lb_error=0

	while [ true ]
	do
		#
		#	if requested bridge is the current bridge and valid, return 0
		#
		[[ ${ldcfac_cbrValid} -eq 1 && "${ldcfac_cbrName}" == "${lb_bridge}" ]] && break

		(( lb_error++ ))

		#
		#	return error code if the bridge name is empty
		#
		[[ -z "${lb_bridge}" ]] && break

		(( lb_error++ ))

		#
		#	if the factory name is empty, 
		#		if there is not a valid global factory name return error code,
		#		otherwise, use it as the factory name
		#
		[[ -z "${lb_factory}" ]] && 
		 {
			[[ $ldcfac_cvalid -eq 1 ]] || break

			lb_factory=$ldcfac_cfname 
		 }

		(( lb_error++ ))

		#
		#	if the factory is not valid, 
		#		or the factory name is not the same as requested,
		#		return error code
		#
		[[ $ldcfac_cvalid -eq 1 && "${lb_factory}" == "${ldcfac_cfname}" ]] || break

		(( lb_error++ ))

		#
		#
		#	populate the bridge keys array
		#
		eval 'ldcfac_cbrKeys=$'"{!$ldcfac_cbrName[@]}"
		[[ $? -eq 0 ]] || break

		(( lb_error++ ))

		#
		#
		#	if the bridge name is not in the bridge keys, return error code
		[[ "${!ldcfac_cbrKeys[@]}" =~ "${lb_bridge}" ]] || break

		#
		#	store global values
		#
		ldcfac_cbrDescription="${ldcfac_cbrKeys[$lb_bridge]}"
		ldcfac_cbrName="${lb_bridge}"
		ldcfac_cbrValid=1

		#
		#	set the error code to "none"
		#
		lb_error=0
		break
	done

	return $lb_error
}

# ***********************************************************************************************************
#
#	ldcFactoryLookupBridge
#		Lookup the bridge name
#
#	Parameters:
#		bridge  = bridge name to check for
#		factory = factory name
#
#	Returns:
#		0 = valid
#		1 = not valid
#
# ********************************************************************************************************
function ldcFactoryBridgeExists()
{
	local    ll_bName="${1}"
	local    ll_bFactory="${2}"

	local -i ll_bError=1

	while [ true ]
	do
		ldcFactoryBridgeExists "${ll_bName}" "${ll_bFactory}"
		[[ $? -eq 0 ]] || break

		(( ll_bError++ ))

		#
		#	store global values
		#
		ldcfac_cbrDescription="${ldcfac_cbrKeys[$ll_bName]}"
		ldcfac_cbrName="${ll_bName}"
		ldcfac_cbrValid=1

		ll_bError=0
		break
	done

	return $ll_bError
}

# ****************************************************************************
#
#	ldcFactoryCBridge
#		Create/Update factory bridge array. 
#
#	parameters:
#		bridge = function bridge name (e.g. - XML, JQ)
#		description = description of the factory bridge
#		uidLength = (optional) number of characters in the uid (default=12)
#
#	returns:
#		0 = no errors
#		non-zero = error number
#
# ****************************************************************************
function ldcFactoryCBridge()
{
	local    lc_bridge=${1:-""}
	local    lc_description=${2:-""}
	local -i lc_uidLength=${3:-"12"}

	local -i lc_error=1
	
	while [ true ]
	do
		[[ -z "$lc_bridge" ]] && break

		(( lc_bridge++ ))

				
		lc_error=0
		break
	done
	
	return $lc_error
}

# ****************************************************************************
#
#	ldcFactoryAdd
#
#		Add/Create factory name and create/update factory bridge array. 
#
#	parameters:
#		factory = function name
#		bridge = function bridge name (e.g. - XML, JQ)
#		description = description of the factory bridge
#		uidLength = (optional) number of characters in the uid (default=12)
#
#	returns:
#		0 = no errors
#		non-zero = error number
#
# ****************************************************************************
function ldcFactoryAdd()
{
	local factory=${1:-""}

	local bridge=${2:-""}
	local description=${3:-""}
	
	local uidLength=${4:-"12"}

	local factoryUid=""
	local bridgeUid=""
    local bridgeArray=""

	local facError=1

	while [ true ]
	do
		[[ -z "${factory}" || -z "${bridge}" ]] && break

		(( facError++ ))

		#
		#	check for factoryname in the registry
		#
		ldcFactoryExists ${factory}
		[[ $? -eq 0 ]] || 
         {
			#
			#  If NOT, create a factory with a new uid
			#
			ldcUIdUnique factoryUid ${uidLength}
			[[ $? -eq 0 ]] || break
			
			(( facError++ ))

			#
			#  store the factory name in the registry with the factory uid
			#
			ldcDeclareArrayEl "ldcfac_registry" "${factory}" "${factoryUid}"
			[[ $? -eq 0 ]] || break
		 }

		(( facError++ ))

		#
		#	fetch the factory uid from the registry
		#
		factoryUid=${ldcfac_registry[$factory]}

		#
		#	create the name of the factory bridge array
		#
		bridgeArray="ldcfac_${factory}_${factoryUid}"

		#
		#	see if it exists
		#
		declare -p "${bridgeArray}" > /dev/null 2>&1
		[[ $? -eq 0 ]] || 
		 {
			#
			#  if not, create the bridge array
			#
			ldcDeclareAssoc "${bridgeArray}"
			[[ $? -eq 0 ]] || break
		 }

		(( facError++ ))

		#
		#	check if the bridge name exists in the bridge array
		#
		ldcFactoryBridgeExists "${bridgeArray}" "${bridge}"
		[[ $? -eq 0 ]] || 
         {
			#
			#  if not, create a bridge name entry in the bridge array
			#
			ldcDeclareArrayEl "${bridgeArray}" "${bridge}" "${description}"
			[[ $? -eq 0 ]] || break
		 }

		(( facError++ ))


		facError=0
		break
	done

	return $facError
}

# ******************************************************************************
# ******************************************************************************
