<?php
namespace Library\DBO;

use Library\Error;

/*
 * 		Library\DBO\Statement is copyright � 2012, 2015. EarthWalk Software.
 * 		Licensed under the Academic Free License version 3.0.
 * 		Refer to the file named License.txt provided with the source, 
 *         or from http://opensource.org/licenses/academic.php
 */
/**
 * Library\DBO\Statement
 *
 * @author Jay Wheeler.
 * @version 1.0
 * @copyright � 2012, 2015. EarthWalk Software.
 * @license Licensed under the Academic Free License version 3.0
 * @package Library
 * @subpackage DBO
 */
class Statement
{
	/**
	 * driver
	 * 
	 * Database driver name
	 * @var string $driver
	 */
	protected $driver;

	/**
	 * statementHandle
	 * 
	 * Statement handle generated by the DBO driver class
	 * @var resource $statementHandle
	 */
	protected $statementHandle;

	/**
	 * driverHandle
	 * 
	 * The driver-based DBO statement class
	 * @var object $driverHandle
	 */
	protected $driverHandle;

	/**
	 * instance
	 * 
	 * A copy of the DBO\Statement object for use in static calls
	 * @var object $instance
	 */
	protected static $instance;

	/**
	 * __construct
	 * 
	 * Class constructor
	 * @param string $driver = the factory name of the statement driver to use
	 * @param object $statementHandle = the statement handle from the DBO driver class
	 */
	public function __construct($driver, $statementHandle)
	{
		$this->driver = $driver;
		$this->statementHandle = $statementHandle;

		$args = func_get_args();
		$this->driverHandle = call_user_func_array(array('\Library\DBO\StatementFactory', 'instantiateClass'), $args);
		self::$instance = $this;
	}

	/**
	 * __destruct
	 *
	 * Class destructor
	 */
	public function __destruct()
	{
		$this->driverHandle = null;
		$this->statementHandle = null;
	}

	/**
	 * __call
	 *
	 * Trap failed method call and re-direct to the current handle object
	 * @param string $method = name of the method being called
	 * @param array $arguments = array of class arguments
	 * @return mixed $result
	 */
	public function __call($method, $arguments)
	{
		return call_user_func_array(array($this->driverHandle, $method), $arguments);
	}

	/**
	 * __callStatic
	 *
	 * Trap failed static method call and re-direct to the current handle object
	 * @param string $method = name of the method being called
	 * @param array $arguments = array of class arguments
	 * @return mixed $result
	 */
	public static function __callStatic($method, $arguments)
	{
		if ((! self::$instance) || (! self::$instance->driverHandle))
		{
			throw new Exception(Error::code('NotInitialized'));
		}

		return call_user_func_array(array(self::$instance->driverHandle, $method), $arguments);
	}

	/**
	 * __get
	 *
	 * Returns the value of the specified property
	 * @param string $name = property to get value for
	 * @return mixed $value
	 */
	public function __get($name)
	{
		return $this->driverHandle->__get($name);
	}

	/**
	 * __set
	 *
	 * Sets the value of the specified property\
	 * @param string $name = property to set value for
	 * @param mixed $value = value of the property
	 */
	public function __set($name, $value)
	{
		$this->driverHandle->__set($name, $value);
	}

	/**
	 * getAvailableDrivers
	 *
	 * Returns an array containing the names of the available drivers
	 * @return array $drivers
	 */
	public static function getAvailableDrivers()
	{
		return StatementFactory::getInstance()->availableKeys();
	}

}
